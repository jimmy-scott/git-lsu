#!/usr/bin/perl

######
# git-lsu, git-lsd: inspect unreachable or dangling objects
#
# version: 0.3 created on 17/06/2012 (DD/MM/YYYY)
# source: http://pub.devbox.be
###
#
# Copyright (C) 2012 Jimmy Scott #jimmy#inet-solutions#be#. Belgium.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   1. Redistributions of source code must retain the above copyright notice,
#      this list of conditions and the following disclaimer.
#
#   2. Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#
#   3. The names of the authors may not be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS "AS IS" AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
# THE POSSIBILITY OF SUCH DAMAGE.
#
######

use strict;
use warnings;

use Getopt::Long qw(:config pass_through require_order
	no_ignore_case no_auto_abbrev prefix_pattern=(--));

# Version string
my $version = "git-lsu version 0.3";

# Command and exec name in use
my $exe;
my $command;

# Mode it is executed in
my $dangle = 0;

# Catchall options
my $a_help = '';
my $a_version = '';
my $a_input_file = '';

# Command 'commit' options
my $c_nonewlines = '';	# Remove newlines between output
my $c_showtree = '';	# List tree for every commit
my $c_dumptree = '';	# Dump tree for every commit

# Options to pass to git
my @gitopts = ();

# This structure is mostly for future use to support analyze mode
my %objects = ( 'commit' => {}, 'tree' => {}, 'blob' => {} );


sub show_usage {
	my $spc = " " x length($exe);
	print STDERR
	"usage: $exe [--help] [--version]\n",
	"       $exe [list] [--input-file=<file>] [git-fsck options]\n",
	"       $exe commit [--input-file=<file>] [--no-newlines]\n",
	"       $spc        [--show-tree] [--dump-tree] [git-show options]\n",
	"       $exe tree [--input-file=<file>] [git-ls-tree options]\n",
	"       $exe blob [--input-file=<file>]\n\n",
	"options:\n",
	"   --input-file=<file>    ",
		"Read data from file instead of running git fsck\n",
	"   --no-newlines          ",
		"Remove newlines between output blocks\n",
	"   --show-tree            ",
		"Show the tree of each commit\n",
	"   --dump-tree            ",
		"Show the tree of each commit recursively\n",
	"\n";
	exit(1);
}

sub show_version {
	print $version, "\n";
	exit(0);
}

sub main {
	$exe = $0;
	$exe =~ s/.+[\/]//;
	
	# Check in which mode we execute
	$dangle = 1 if ($exe =~ /lsd/);
	
	# Parse & check args
	parse_args();
	
	# Args look fine, so get items
	my $items = get_objects();
	exit(0) if ($items == 0);
	
	# Run requested command
	if ($command eq 'list') {
		list_objects();
	} elsif ($command eq 'commit') {
		show_commits();
	} elsif ($command eq 'tree') {
		show_trees();
	} elsif ($command eq 'blob') {
		show_blobs();
	} else {
		# Never reached
		show_usage();
	}
}

sub parse_args {
	# If first arg is option, run as 'list' command
	if (@ARGV && ($ARGV[0] =~ /^\-\-/)) {
		$command = 'list';
	} else {
		$command = shift @ARGV || 'list';
	}
	
	my $optok;
	my %options;
	my %alloptions;
	
	# List of all supported commands
	my @commands = ('list', 'commit', 'tree', 'blob');
	
	# Catch these options for all commands
	%alloptions = (
		'help'		=>	\$a_help,
		'version'	=>	\$a_version,
		'input-file=s'	=>	\$a_input_file,
	);
	
	# Catch these options for individual commands
	if ($command eq 'commit') {
		%options = (
			'no-newlines'	=>	\$c_nonewlines,
			'show-tree'	=>	\$c_showtree,
			'dump-tree'	=>	\$c_dumptree,
		);
	#} elsif ($command eq 'tree') {
	#} elsif ($command eq 'blob') {
	#} else {
	}
	
	# Verify we are running a known command
	show_usage() unless (grep(/^${command}$/, @commands));
	
	# Parse options, return help or version immediately
	$optok = GetOptions ((%options, %alloptions));
	show_usage() if ((!$optok) || $a_help);
	show_version() if ($a_version);
	@gitopts = @ARGV;
	
	# Try to avoid incorrect usage
	if (@gitopts) {
		# Why do I even bother using Getopt if I have to
		# do crap like this? If the options I provide have
		# invalid or missing parameters, they shouldn't be
		# passed on, even for pass_through mode it's stupid.
		show_usage() if ($gitopts[0] =~ /--input-file=?/);
		
		# These options to not support pass_through
		show_usage() if ($command eq 'blob');
	}
}

sub read_file {
	my $file = shift;
	my ($fh, $out);
	
	if (open($fh, '<', $file)) {
		local $/;
		$out = <$fh>;
	} else {
		print STDERR "$exe: $file: $!\n";
		return undef;
	}
	
	close($fh);
	return $out;
}

sub get_objects {
	my $filter = shift;
	my $items = 0;
	my ($cmd, $fsck);
	
	# Get unreachable or dangling objects
	# Expected format: <state> <type> <sha1>
	if ($a_input_file ne '') {
		# Read from file
		$fsck = read_file($a_input_file);
		
		if (!defined($fsck)) {
			print STDERR "$exe: failed to read `$a_input_file'.\n";
			exit(1);
		}
	} else {
		# Read from git command
		$cmd = "git fsck";
		$cmd .= " --unreachable" unless ($dangle);
		
		# List command may pass arguments to fsck
		if ($command eq 'list' && @gitopts) {
			$cmd .= " " . join(" ", @gitopts);
		}
		
		$fsck = `$cmd`;
		
		if (!defined($fsck)) {
			print STDERR "$exe: fialed to execute `$cmd'.\n";
			exit(1);
		}
	}
	
	# Structure will look like this:
	# %objects -> %type -> %sha1 -> %prop = 'value'
	for my $line (split /\n/, $fsck) {
		if ($line =~ /^(unreachable|dangling)\s+(commit|blob|tree)\s+([a-f0-9]+)$/) {
			my $state = $1; my $type = $2; my $sha = $3;
			next if ($dangle && $state ne "dangling");
			next if ((!$dangle) && $state ne "unreachable");
			next if (defined $filter && $type ne $filter);
			$objects{$type}{$sha} = {};
			$items++;
		} else {
			# Enexpected format
			print STDERR "$exe: unknown format: `$line'\n";
		}
	}
	
	# Return the number of items
	return $items;
}

sub list_objects {
	my $sha;
	
	my $state = $dangle ? "dangling" : "unreachable";
	
	for $sha (keys %{$objects{'commit'}}) {
		print "$state commit $sha\n";
	}
	
	for $sha (keys %{$objects{'tree'}}) {
		print "$state tree $sha\n";
	}
	
	for $sha (keys %{$objects{'blob'}}) {
		print "$state blob $sha\n";
	}
}

sub show_commits {
	my %tss = ();
	my @stss = ();
	my @ssha = ();
	
	# Get timestamp and subject into temp structure
	for my $sha (keys %{$objects{'commit'}}) {
		my $out = `git show --format='%at%n%s' --quiet $sha`;
		my ($time, $subject) = split(/\n/, $out);
		$tss{$time}{$sha} = $subject;
	}
	
	# Get a sorted list of timestamp
	@stss = sort {$b <=> $a} keys %tss;
	
	# Sort objects with same timestamp by subject type
	for my $ts (@stss) {
		my (@wip, @ind, @oth);
		for my $sha (keys %{$tss{$ts}}) {
			my $subject = $tss{$ts}{$sha};
			if ($subject =~ /^WIP\son\s\S+:\s/) {
				push @wip, $sha;
			} elsif ($subject =~ /^index\son\s\S+:\s/) {
				push @ind, $sha;
			} else {
				push @oth, $sha;
			}
		}
		push @ssha, (@wip, @ind, @oth);
	}
	
	# Print commits
	for my $sha (@ssha) {
		my $cmd;
		
		if (@gitopts) {
			$cmd = "git show " . join(' ', @gitopts) . " $sha";
		} else {
			$cmd = "git show --quiet $sha";
		}
		
		my $out = `$cmd`;
		
		# Add or remove newlines
		$out =~ s/\n+$/\n/ if ($c_nonewlines);
		print $out;
		print "\n" unless ($c_nonewlines || ($out =~ /\n\n$/));
		
		# Print c_showtree or c_dumptree
		if ($c_dumptree) {
			$out = `git ls-tree -r --full-tree $sha`;
			print $out, "\n";
		} elsif ($c_showtree) {
			$out = `git ls-tree --full-tree $sha`;
			print $out, "\n";
		}
	}
}

sub show_trees {
	my $sha;
	my $cmd = "git ls-tree --full-tree";
	
	if (@gitopts) {
		$cmd .= " " . join(' ', @gitopts);
	}
	
	for $sha (keys %{$objects{'tree'}}) {
		print "tree ${sha}\n\n";
		my $out = `$cmd $sha`;
		print $out, "\n";
	}
}

sub show_blobs {
	my $sha;
	my $cmd = "git show";
	
	# Has no point AFAIK
	#if (@gitopts) {
	#	$cmd .= " " . join(' ', @gitopts);
	#}
	
	for $sha (keys %{$objects{'blob'}}) {
		print "blob ${sha}\n\n";
		print "[", "=" x 69, ">]", "\n\n";
		
		my $out = `$cmd $sha`;
		
		# Try not to screwup the terminal
		if (check_is_binary(\$out)) {
			print "(binary data: ", length($out), " bytes)\n";
		} else {
			print $out;
		}
		
		print "\n", "[<", "=" x 69, "]", "\n\n";
	}
}

sub check_is_binary {
	my $data_ref = shift;
	
	my $data = substr($${data_ref}, 0, 8000);
	return 1 if ($data =~ /\0/); 
	return 0;
}

main();

